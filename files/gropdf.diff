*** gropdf.old	2024-09-21 00:13:32.440734365 +0000
--- gropdf	2024-09-21 00:13:32.448734246 +0000
***************
*** 24,32 ****
  use warnings;
  require 5.8.0;
  use Getopt::Long qw(:config bundling);
! use Encode qw(encode);
  use POSIX qw(mktime);
  
  use constant
  {
      WIDTH               => 0,
--- 24,43 ----
  use warnings;
  require 5.8.0;
  use Getopt::Long qw(:config bundling);
! use Encode qw(encode decode);
  use POSIX qw(mktime);
  
+ our $VERSION = "2024.06.30";
+ 
+ use List::Util qw(min max sum uniq);
+ use File::Temp qw/tempfile/;
+ #use feature 'say';
+ use Data::Dumper qw/Dumper/;
+ $Data::Dumper::Indent = 1;
+ $Data::Dumper::Terse = 1;
+ use lib qw(/vagrant/font-ttf/lib);
+ use Font::TTF::Font;
+ 
  use constant
  {
      WIDTH               => 0,
***************
*** 455,460 ****
--- 466,478 ----
  my $stats=0;
  my $unicodemap;
  my $options=7;
+ 
+ # The width of a space is different for horizontal and vertical writing.
+ # This is because the cid of a space is different for horizontal and
+ # vertical writing.  Until I understand this exactly, I will disable the
+ # USESPACE option.
+ 
+ $options &= ~USESPACE;          # xxxxx
  my $PDFver=1.7;
  my @idirs;
  
***************
*** 487,493 ****
  
  if ($version)
  {
!     print "GNU gropdf (groff) version $cfg{GROFF_VERSION}\n";
      exit;
  }
  
--- 505,512 ----
  
  if ($version)
  {
!     #print "GNU gropdf (groff) version $cfg{GROFF_VERSION}\n";
!     print "GNU gropdf (groff) version $cfg{GROFF_VERSION}-$VERSION\n";
      exit;
  }
  
***************
*** 721,726 ****
--- 740,750 ----
  {
      my $f=$fontlst{$fontno};
      my $fnt=$f->{FNT};
+ 
+     # Separate the cid font output process into PutCIDFont().
+     PutCIDFont($fontno), next if $fnt->{cidfont}; # xxxxx
+ 
+     # Type1
      my $nam=$fnt->{NAM};
      my ($head,$body,$tail);
      my $objno=$f->{OBJNO};
***************
*** 857,863 ****
--- 881,1009 ----
              }
          }
      }
+ }
+ 
+ 
+ # pass2
+ my %DOWNLOAD;   # xxxxx
+ 
+ foreach my $fontno (sort keys %fontlst)
+ {
+     my $f = $fontlst{$fontno};
+     my $fnt = $f->{FNT};
+     if ($fnt->{cidfont}) {
+         my $DOWNLOAD = $DOWNLOAD{$fnt->{' FontName'}};
+         $fnt->{tounicode} = $DOWNLOAD->{tounicode};
+         $DOWNLOAD->{ucmap} //= unicode_cmap($fnt);
+         GetObj($fnt->{font_resource})->{ToUnicode} = $DOWNLOAD->{ucmap}
+             if $DOWNLOAD->{ucmap};
+         unless ($DOWNLOAD->{fontfile}) {
+             if ($embedall) {
+                 if (my $fontfile = fontfile($f->{NM}, $fnt)) {
+                     $DOWNLOAD->{fontfile} = $fontfile;
+                 }
+             }
+             if ($DOWNLOAD->{fontfile}) {
+                 # flatedecode
+                 my $p = GetObj($DOWNLOAD->{fontfile});
+                 if ($gotzlib && ($options & COMPRESS) && !$p->{DATA}{Filter} &&
+                     !$debug) {
+                     $p->{STREAM} = Compress::Zlib::compress($p->{STREAM});
+                     $p->{DATA}{Filter} = '/FlateDecode';
+                     $p->{DATA}{Length} = length $p->{STREAM};
+                 }
+             }
+         }
+ 
+         my $tag = join '', map chr(int((rand(26)))+65), 1..6;
+         $DOWNLOAD->{' FontName'} //= join '+', $tag, $fnt->{' FontName'};
+         my $p = GetObj($fnt->{font_descriptor});
+         for ($DOWNLOAD->{fontfile}) {
+             $p->{FontFile3} = $_ if defined;
+         }
+         $p->{' FontName'} = "/".$DOWNLOAD->{' FontName'};
+     }
+ 
+ }
+ 
+ 
+ sub fontfile {
+     my ($fn, $fnt) = @_;
+ 
+     #my $otf = $fnt->{' OTF'};
+     #return $fnt->{' OTF'}->{'CFF '}->as_string;
+ 
+     my @cids = keys %{$fnt->{tounicode}};
+     return undef if !@cids || @cids == 1 && $cids[0] == 0;;
+     my @gids = map { $fnt->{' CID2GID'}->[$_] } @cids; # xxxxx
+ 
+     my ($sh, $sub_font) = tempfile(DIR => '/tmp', SUFFIX => '.otf');
+     my ($gh, $gid_file) = tempfile(DIR => '/tmp', SUFFIX => '.txt');
+     #my $gids = join ',', @gids;
+     print $gh join(',', @gids), "\n";
+     close $gh;
+     my @pyftsubset = (
+         'pyftsubset', $fnt->{fontfile}, # $PATH_otf,
+         "--output-file=$sub_font",
+         #"--gids=$gids",
+         "--gids-file=$gid_file",
+         #'--retain-gids',
+         '--notdef-outline',
+ 
+         #'--notdef-glyph',
+         #'--recommended-glyphs',
+         #'--layout-features=*',
+         #'--glyph-names',
+         #'--symbol-cmap',
+         #'--legacy-cmap',
+         #'--desubroutinize',
+         #'--passthrough-tables',
+     );
+     print STDERR "# @pyftsubset\n" if $debug;
+     system @pyftsubset;
+ 
+     if ($debug) {
+         #my $f = substr $fn, 1;
+         my $f = $fnt->{name};
+         print STDERR "# cp $sub_font $f.otf\n";
+         system "cp $sub_font $f.otf";
+ 	if (0) {
+ 	    if (open my ($fh), ">$f.cff") {
+ 		my $otf = $fnt->{' OTF'};
+ 		print $fh $otf->{'CFF '}->as_string;
+ 		close $fh;
+ 	    }
+ 	}
+     }
+ 
+     my $font_stream;
+     my $subtype;
+     my $otf = Font::TTF::Font->open($sub_font);
+     if ($otf && $otf->{'CFF '}) {
+         my $fh = $otf->{'CFF '}{' INFILE'};
+         $fh->seek($otf->{'CFF '}{' OFFSET'}, 0);
+         $fh->read($font_stream, $otf->{'CFF '}{' LENGTH'});
+         $subtype = "/CIDFontType0C";
+     } else {
+         if (open my $fd, $sub_font) {
+             local $/ = undef;
+             $font_stream = <$fd>;
+         } else {
+             Warn("can't open '$sub_font'");
+             $font_stream = '';
+         }
+         $subtype = "/OpenType";
+     }
+ 
+     unlink $sub_font, $gid_file;
  
+     my $fontfile = BuildObj(++$objct, {
+         "Subtype" => $subtype,
+     });
+     $obj[$objct]->{STREAM} = $font_stream;
+     $obj[$objct]->{DATA}{Length} = length $font_stream;
+ 
+     $fontfile;
  }
  
  foreach my $j (0..$#{$pages->{Kids}})
***************
*** 993,1003 ****
--- 1139,1677 ----
  print "\% Pages=$pages->{Count}\n" if $stats;
  
  
+ sub PutCIDFont
+ {
+     my $fontno = shift;
+     my $fontnm = $fontno;
+ 
+     my $f = $fontlst{$fontno};
+ 
+     my $fnt = $f->{FNT};
+     my $otf = $fnt->{' OTF'};
+ 
+     0 and print STDERR 'keys %{$f->{FNT}}: ', "@{[ sort keys %{$f->{FNT}} ]}", "\n";
+ 
+ =begin comment
+ 
+ ALLOC CHARSET DIFF NAM NO TRFCHAR WIDTH ascent capheight cidfont encoding
+ fntbbox fontfile internalname lastchr ligatures name nospace opentype slant
+ spacewidth t1flags
+ 
+ =end comment
+ 
+ =cut
+ 
+     0 and print STDERR "ref \$f->{FNT}{$_}: ", ref $f->{FNT}{$_}, "\n"
+         for sort keys %{$f->{FNT}};
+ 
+ 
+ =begin comment
+ 
+ ref $f->{FNT}{ALLOC}: 
+ ref $f->{FNT}{CHARSET}: ARRAY
+ ref $f->{FNT}{DIFF}: ARRAY
+ ref $f->{FNT}{NAM}: HASH
+ 
+ The keys are the names (names of the characters) and the values ​​are the
+ charsets of the groff_fonts.
+ 
+ ref $f->{FNT}{NO}: ARRAY
+ 
+ The index is code (character number), the value is name (character name).
+ 
+ ref $f->{FNT}{TRFCHAR}: ARRAY
+ ref $f->{FNT}{WIDTH}: ARRAY
+ ref $f->{FNT}{ascent}: 
+ ref $f->{FNT}{capheight}: 
+ ref $f->{FNT}{cidfont}: 
+ ref $f->{FNT}{encoding}: 
+ ref $f->{FNT}{fntbbox}: ARRAY
+ ref $f->{FNT}{fontfile}: 
+ ref $f->{FNT}{internalname}: 
+ ref $f->{FNT}{lastchr}: 
+ ref $f->{FNT}{ligatures}: 
+ ref $f->{FNT}{name}: 
+ ref $f->{FNT}{nospace}: 
+ ref $f->{FNT}{opentype}: 
+ ref $f->{FNT}{slant}: 
+ ref $f->{FNT}{spacewidth}: 
+ ref $f->{FNT}{t1flags}: 
+ 
+ =end comment
+ 
+ =cut
+ 
+     0 and print STDERR "ref \$f->{FNT}{WIDTH}: ", Dumper($f->{FNT}{WIDTH});
+ 
+     for my $i (0 .. $#{$fnt->{TRFCHAR}}) {
+         for my $j (0 .. $#{$fnt->{TRFCHAR}->[$i]}) {
+             my $cid = $fnt->{CHARSET}->[$i]->[$j];
+             #my $gid = $fnt->{' CID2GID'}->[$cid];
+             my $nam = $fnt->{TRFCHAR}->[$i]->[$j];
+             my $unicode = $fnt->{NAM}{$nam}[UNICODE];
+             $fnt->{tounicode}{$cid} = decode "UTF16-BE",
+                 pack "n*", map hex($_), split '_', $unicode;
+         }
+     }
+ 
+     # Type 0 Font Dictionaries (Table 121)
+     my $font_resource = BuildObj(++$objct, {
+         Type => "/Font",
+         Subtype => "/Type0",
+         BaseFont => "/" . join('-', $fnt->{' FontName'}, $fnt->{' CMapName'}),
+         Encoding => "/".$fnt->{' Encoding'},
+         # DescendantFonts => [ $cid_font ], # [ 7 0 R ],
+         # ToUnicode => undef, # 8 0 R,
+     });
+     $fontlst{$fontnm}->{OBJ} = $font_resource;
+ 
+     #push(@fontdesc, EmbedFont($fontnm,$fnt));
+     $pages->{Resources}->{Font}->{'F'.$fontnm} = $fontlst{$fontnm}->{OBJ};
+     # $obj[$objct-2]->{DATA}->{'ToUnicode'} = $textenccmap if exists($fnt->{ToUnicode});
+ 
+ 
+     # CIDFonts (Table 117)
+     my $cid_font = BuildObj(++$objct, {
+         Type => "/Font",
+         Subtype => "/CIDFontType0", # if OpenType
+         BaseFont => "/".$fnt->{' FontName'}, # CIDFontName
+         CIDSystemInfo => $fnt->{' CIDSystemInfo'},
+         # FontDescriptor => undef, # 8 0 R
+     });
+     GetObj($font_resource)->{DescendantFonts} = [ $cid_font ];
+ 
+     my $flags = 0;
+     my $special = 0;
+     #$flags += 1 << ( 1 - 1); # FixedPitch
+     $flags += 1 << ( 1 - 1) if $fnt->{' isFixedPitch'};
+     #$flags += 1 << ( 2 - 1); # Serif
+     $flags += 1 << ( 2 - 1) if $fnt->{' FontName'} =~ /Serif/;
+     #$flags += 1 << ( 3 - 1); # Symbolic
+     $flags += 1 << ( 3 - 1) if $special;
+     #$flags += 1 << ( 4 - 1); # Script
+     #$flags += 1 << ( 6 - 1); # Nonsymbolic
+     $flags += 1 << ( 6 - 1) if !$special;
+     #$flags += 1 << ( 7 - 1); # Italic
+     $flags += 1 << ( 7 - 1) if $fnt->{slant};
+     #$flags += 1 << (17 - 1); # AllCap
+     #$flags += 1 << (18 - 1); # SmallCap
+     #$flags += 1 << (19 - 1); # ForceBold
+ 
+     # Entries common to all font descriptors (Table 122)
+     my $font_descriptor = BuildObj(++$objct, {
+         Type        => "/FontDescriptor",
+         Flags       => $flags,
+         FontName    => "/".$fnt->{' FontName'},
+         FontBBox    => $fnt->{' FontBBox'},
+         ItalicAngle => $fnt->{slant},
+         Ascent      => $fnt->{' Ascender'},
+         Descent     => $fnt->{' Descender'},
+         CapHeight   => $fnt->{' CapHeight'},
+         StemV       => 0,
+         #FontFile3"  => "", # 9 0 R
+     });
+     GetObj($cid_font)->{FontDescriptor} = $font_descriptor;
+ 
+     my $p = GetObj($cid_font);
+     if ($fnt->{vertical}) {
+         $p->{DW2} = $fnt->{' DW2'};
+         $p->{W2} = w2_array($fnt);
+     } else {
+         $p->{DW} = $fnt->{' DW'};
+         $p->{W} = w_array($fnt);
+     }
+ 
+     $fnt->{font_descriptor} = $font_descriptor;
+     $fnt->{font_resource} = $font_resource;
+ 
+     my $DOWNLOAD = $DOWNLOAD{$fnt->{' FontName'}} //= {};
+     $DOWNLOAD->{tounicode} = {
+         %{$DOWNLOAD->{tounicode} // {}},
+         %{$fnt->{tounicode} // {}},
+     };
+ 
+     0 and print STDERR Dumper({
+         #'$font_resource' => GetObj($font_resource),
+         #'$cid_font' => GetObj($cid_font),
+         #'$font_descriptor' => GetObj($font_descriptor),
+         #'$pages' => GetObj($pages), # xxxxx
+     });
+ 
+ }
+ 
+ 
+ sub w_array {
+     my ($fnt) = @_;
+     my $otf = $fnt->{' OTF'};
+     my @cids = keys %{$fnt->{tounicode}};
+ 
+     my @w;
+     my $n = 0;
+     my $lastc = -1;
+     for my $c (sort { $a <=> $b } @cids) {
+         my $gid = $fnt->{' CID2GID'}->[$c]; # xxxxx
+         my $w;
+         if ($otf) {
+             if ($fnt->{vertical}) {
+                 $w = $otf->{vmtx}{advance}[$gid] // $fnt->{' DW'};
+                 if ($fnt->{' GPOS'}) {
+                     for ($fnt->{' GPOS'}{$gid}{YAdvance}) {
+                         $w += $_ if defined;
+                     }
+                 }
+             } else {
+                 $w = $otf->{hmtx}{advance}[$gid] // $fnt->{' DW'};
+                 if ($fnt->{' GPOS'}) {
+                     for ($fnt->{' GPOS'}{$gid}{XAdvance}) {
+                         $w += $_ if defined;
+                     }
+                 }
+             }
+         } else {
+             $w = $fnt->{' DW'};
+         }
+         if ($w == $fnt->{' DW'}) {
+             $n++;
+             next;
+         }
+         if (@w && $lastc + 1 == $c && $n == 0) {
+             if (ref $w[-1] eq 'ARRAY') {
+                 push @{$w[-1]}, $w;
+                 $lastc = $c;
+                 next;
+             }
+         }
+         push @w, $c, [ $w ];
+         $lastc = $c;
+         $n = 0;
+     }
+ 
+     if (1) {
+         my $thresh = 4;
+         my @w2 = ();
+         my @t = ();
+         while (my ($c, $list) = splice @w, 0, 2) {
+             @t = ($c, [shift @$list]);
+             while (defined (my $w = shift @$list)) {
+                 $c++;
+                 if (@t == 3) {
+                     if ($t[2] == $w) {
+                         $t[1] = $c;
+                     } else {
+                         push @w2, @t;
+                         @t = ($c, [ $w ]);
+                     }
+                 } elsif (@t == 2) {
+                     my $cons = 1;
+                     for (1 .. $thresh) {
+                         $cons = 0, last unless @{$t[1]} >= $_ && $t[1]->[-$_] == $w;
+                     }
+                     if ($cons) {
+                         pop @{$t[1]} for 1 .. $thresh;
+                         push @w2, @t if @{$t[1]} > 0;
+                         @t = ($c - $thresh, $c, $w);
+                     } else {
+                         push @{$t[1]}, $w;
+                     }
+                 } else {
+                     die "program error: t = ", str_w(\@t);
+                 }
+             }
+             push @w2, @t;
+             @t = ();
+         }
+         push @w2, @t;
+         @w = @w2;
+     }
+ 
+     \@w;
+ }
+ 
+ 
+ sub w2_array {
+     my ($fnt) = @_;
+     my $otf = $fnt->{' OTF'};
+     my @cids = keys %{$fnt->{tounicode}};
+ 
+     my @w2;
+     #my $n = 0;
+     my $lastc = -1;
+     for my $c (sort { $a <=> $b } @cids) {
+ 
+ 	# The default position vector v and vertical displacement vector
+ 	# w1 are specified by DW2, which is an array of two values: the
+ 	# vertical component of the position vector v and the vertical
+ 	# component of the displacement vector w1 (w1 is a downward
+ 	# vector from the origin (top-center) of the current character
+ 	# to the origin of the next character. The horizontal component
+ 	# of the position vector v is half the glyph width, and the
+ 	# horizontal component of the displacement vector w1 is zero.
+ 
+         # w0 = (1000, 0)
+         # w1 = (0, -1000)
+         # v  = (c.width / 2 - 0,  c.height + c.descender) = (500, 880)
+         # dw2 = (v.y, w1.y) = (880, -1000)
+ 
+         my ($w1_x, $w1_y, $v_x, $v_y) = (
+             0,                 # w1_x
+             $fnt->{' DW2'}[1],    # w1_y
+             $fnt->{' DW'} / 2,    # v_x
+             $fnt->{' DW2'}[0]     # v_y
+         );
+ 
+         if ($otf) {
+             my $gid = $fnt->{' CID2GID'}->[$c]; # xxxxx
+             my $v = $fnt->{' GPOS'}->{$gid};
+             if ($fnt->{vertical}) {
+                 $w1_y = -($otf->{vmtx}{advance}[$gid] // 1000);
+                 for ($v->{YAdvance}) {
+                     $w1_y -= $_ if defined;
+                 }
+             } else {
+                 $w1_x = $otf->{hmtx}{advance}[$gid] // 1000;
+                 for ($v->{XAdvance}) {
+                     $w1_x += $_ if defined;
+                 }
+             }
+         }
+ 
+         if (!ref $w2[-1] && @w2 >= 4 && $w2[-3] == $w1_y && $w2[-2] == $v_x && $w2[-1] == $v_y) {
+             $w2[-4] = $c;
+             $lastc = $c;
+             next;
+         }
+ 
+         if ($lastc + 1 == $c && ref $w2[-1] eq 'ARRAY') {
+             push @{$w2[-1]}, $w1_y, $v_x, $v_y;
+             $lastc = $c;
+             next;
+         }
+ 
+         push @w2, $c, [ $w1_y, $v_x, $v_y ];
+         $lastc = $c;
+         #$n = 0;
+     }
+ 
+     \@w2;
+ }
+ 
+ 
+ sub unicode_cmap {
+     my ($fnt) = @_;
+     return undef unless %{$fnt->{tounicode}};
+ 
+     my $CMapName = $fnt->{' CMapName'},
+     my $CIDSystemInfo = {
+         "Registry" => "(Adobe)",
+         "Ordering" => "(UCS)",
+         "Supplement" => 0,
+     };
+     my $ucmap = BuildObj(++$objct, {
+         "Type" => "/CMap",
+         "CMapName" => "/$CMapName",
+         "CIDSystemInfo" => $CIDSystemInfo,
+     });
+ 
+     if ($fnt->{' CMapType'} == 2) {
+         $obj[$objct]->{STREAM} = join "\n", grep !/^[%]/, split /\n/, <<endstream;
+ /CIDInit /ProcSet findresource begin
+ 12 dict begin
+ begincmap
+ /CMapName /$CMapName def
+ /CMapType $fnt->{' CMapType'} def
+ /CIDSystemInfo <<
+ @{[ %$CIDSystemInfo ]}
+ >> def
+ @{[ codespacerange([ map pack("U*", $_), keys %{$fnt->{tounicode}} ]) ]}
+ @{[ bfrange($fnt->{tounicode}) ]}
+ endcmap
+ CMapName currentdict /CMap defineresource pop
+ end
+ end
+ endstream
+         $obj[$objct]->{DATA}{Length} = length $obj[$objct]->{STREAM};
+ 
+     } elsif ($fnt->{' CMapType'} == 1) {
+         $obj[$objct]->{STREAM} = join "\n", grep !/^[%]/, split /\n/, <<endstream;
+ /CIDInit /ProcSet findresource begin
+ 12 dict begin
+ begincmap
+ /CMapName /$CMapName def
+ /CMapType $fnt->{' CMapType'} def
+ /CIDSystemInfo <<
+ @{[ %$CIDSystemInfo ]}
+ >> def
+ @{[ codespacerange([ values %{$fnt->{tounicode}} ]) ]}
+ @{[ cidrange($fnt->{tounicode}) ]}
+ endcmap
+ CMapName currentdict /CMap defineresource pop
+ end
+ end
+ endstream
+         $obj[$objct]->{DATA}{Length} = length $obj[$objct]->{STREAM};
+ 
+     } elsif (defined $fnt->{' CMapType'}) {
+         print STDERR "CMapType is: ", $fnt->{' CMapType'}, " (ignored).\n";
+     }
+ 
+     $ucmap;
+ }
+ 
+ 
+ sub bfrange {
+     my ($bfchar) = @_;
+     my $chunksize = 100;
+     my @bfrange;
+     my @bfchar;
+ 
+     my @k = sort { $a <=> $b } keys %{$bfchar};
+     while (@k > 0) {
+         my $i = 0;
+         while ($i + 1 <= $#k) {
+             #last if $bfchar->{$k[$i]} + 1 != $bfchar->{$k[$i + 1]};
+             last if $k[$i] + 1 != $k[$i + 1];
+             my $a = [ map ord($_), split //, $bfchar->{$k[$i]} ];
+             my $b = [ map ord($_), split //, $bfchar->{$k[$i + 1]} ];
+             my $j = $#{$a};
+             last if $#{$a} != $#{$b};
+             last if $a->[$j] + 1 != $b->[$j];
+             1 while (--$j >= 0 && $a->[$j] == $b->[$j]);
+             last if $j >= 0;
+             $i++;
+         }
+         if ($i > 0) {
+             my @t = splice @k, 0, $i + 1;
+             push @bfrange, [ $t[0], $t[-1] ];
+         } elsif ($i <= $#k) {
+             push @bfchar, shift @k;
+             $i++;
+         }
+     }
+ 
+     0 and print STDERR Dumper({ bfrange => \@bfrange, bfchar => \@bfchar}); # xxxxx
+ 
+     join "\n", (
+         blocking('bfrange', map {
+             my @hex = map sprintf('%04X', $_), unpack 'n*',
+                 encode 'UTF16-BE', $bfchar->{$_->[0]};
+             join ' ', sprintf("<%04X>", $_->[0]), sprintf("<%04X>", $_->[1]), "<@hex>";
+         } @bfrange),
+         blocking('bfchar', map {
+             my @hex = map sprintf("%04X", $_), unpack "n*",
+                 encode "UTF16-BE", $bfchar->{$_};
+             join ' ', sprintf("<%04X>", $_), "<@hex>";
+         } @bfchar),
+     );
+ }
+ 
+ 
+ sub codespacerange {
+     my ($code) = @_;
+     my @list;
+     my %seen;
+     for (sort grep !$seen{$_}++, @$code) {
+         if (@list) {
+             if (length $list[-1]->[0] == length) {
+                 my @s = $list[-1]->[0] =~ /^(.*?)(.|\n)$/;
+                 my @x = /^(.*?)(.|\n)$/;
+                 if ($x[0] eq $s[0]) {
+                     $list[-1]->[1] = $_;
+                     next;
+                 }
+             }
+         }
+         if (@list) {
+             my @s = unpack 'n*', encode 'UTF16-BE', $list[-1]->[0];
+             my @e = unpack 'n*', encode 'UTF16-BE', $list[-1]->[1];
+             my @n = unpack 'n*', encode 'UTF16-BE', $_;
+             if ($e[0] == $n[0]) {
+                 print STDERR join ' ', 'codespacerange:',
+                     "<@{[ map sprintf('%04X', $_), @e ]}>",
+                     'and',
+                     "<@{[ map sprintf('%04X', $_), @n ]}>",
+                     'overlapped',
+ 		    "\n";
+             }
+         }
+         push @list, [ $_, $_ ];
+     }
+     blocking('codespacerange', map {
+         my @s = map sprintf("%04X", $_), unpack 'n*', encode 'UTF16-BE', $_->[0];
+         my @e = map sprintf("%04X", $_), unpack 'n*', encode 'UTF16-BE', $_->[1];
+         "<@s> <@e>";
+     } @list);
+ }
+ 
+ 
+ sub cidrange {
+     my ($tounicode) = @_;
+     my @list;
+     for (sort { $tounicode->{$a} cmp $tounicode->{$b} } keys %{$tounicode}) {
+         if (@list) {
+             if (length $list[-1]->[0] == length $tounicode->{$_}) {
+                 my @s = $list[-1]->[0] =~ /^(.*?)(.|\n)$/;
+                 my @x = $tounicode->{$_} =~ /^(.*?)(.|\n)$/;
+                 if ($x[0] eq $s[0] && $list[-1]->[2] + (ord($x[1]) - ord($s[1])) == $_) {
+                     $list[-1]->[1] = $tounicode->{$_};
+                     next;
+                 }
+             }
+         }
+         push @list, [ $tounicode->{$_}, $tounicode->{$_}, $_ ];
+     }
+     join "\n", (
+         blocking('cidrange', map {
+             my @s = map sprintf("%04X", $_), unpack 'n*', encode 'UTF16-BE', $_->[0];
+             my @e = map sprintf("%04X", $_), unpack 'n*', encode 'UTF16-BE', $_->[1];
+             join ' ', "<@s>", "<@e>", $_->[2];
+         } grep $_->[0] ne $_->[1], @list),
+         blocking('cidchar', map {
+             my @s = map sprintf("%04X", $_), unpack 'n*', encode 'UTF16-BE', $_->[0];
+             "<@s> $_->[2]";
+         } grep $_->[0] eq $_->[1], @list),
+     );
+ }
+ 
+ 
+ sub blocking {
+     my ($name, @in) = @_;
+     my $size = 100;
+     my @out = ();
+     while (@in) {
+         my $n = min($size, scalar @in);
+         push @out, "$n begin${name}";
+         push @out, splice @in, 0, $n;
+         push @out, "end${name}";
+     }
+     join "\n", @out;
+ }
+ 
+ 
  sub MakeMatrix
  {
      my $fontxrev=shift||0;
      my @mat=($frot)?(0,1,-1,0):(1,0,0,1);
  
+     my ($a, $b, $c, $d);
+     if (!$frot) {
+         if (!($thisfnt && $thisfnt->{vertical})) {
+             ($a, $b, $c, $d) = (1, 0, 0, 1);
+             $c = $thisfnt->{' skew'} if $thisfnt && $thisfnt->{' skew'};
+         } else {
+             ($a, $b, $c, $d) = (0, 1, -1, 0);
+             $a = $thisfnt->{' skew'} if $thisfnt && $thisfnt->{' skew'};
+         }
+     } else {
+         if (!($thisfnt && $thisfnt->{vertical})) {
+             ($a, $b, $c, $d) = (0, 1, -1, 0);
+             $d = $thisfnt->{' skew'} if $thisfnt && $thisfnt->{' skew'};
+         } else {
+             ($a, $b, $c, $d) = (-1, 0, 0, -1);
+             $b = $thisfnt->{' skew'} if $thisfnt && $thisfnt->{' skew'};
+         }
+     }
+     @mat = ($a, $b, $c, $d);
+ 
      if (!$frot)
      {
          if ($env{FontHT} != 0)
***************
*** 3005,3013 ****
--- 3679,3694 ----
      $fct+=length($msg);
  }
  
+ my $thisono;
  sub PutObj
  {
      my $ono=shift;
+ 
+     # $thisono is the object number being processed by PutField.  It is
+     # used in the error message output when $fld is undef in
+     # PutField. -- obuk
+ 
+     $thisono = $ono;            # xxxxx
      my $inmem=shift;
  
      if ($inmem)
***************
*** 3030,3035 ****
--- 3711,3717 ----
      }
      PutField(\$msg,$obj[$ono]->{DATA});
      PutStream(\$msg,$ono) if exists($obj[$ono]->{STREAM});
+     $thisono = undef;
      Put($msg."endobj\n");
  }
  
***************
*** 3049,3054 ****
--- 3731,3740 ----
      my $term=shift||"\n";
      my $typ=ref($fld);
  
+     unless (defined $fld) {
+         Warn("PutField: fld is undef; check '$thisono 0 obj'") unless defined $fld;
+         return;
+     }
      if ($typ eq '')
      {
          $$pmsg.="$fld$term";
***************
*** 3183,3189 ****
              $stg=2,next if $key eq 'kernpairs';
              $stg=3,next if lc($_) eq 'charset';
  
!             $fnt{$key}=$val
          }
          elsif ($stg == 2)
          {
--- 3869,3881 ----
              $stg=2,next if $key eq 'kernpairs';
              $stg=3,next if lc($_) eq 'charset';
  
! 	    # Lines in the groff_font file that have only $key and no
! 	    # $val should evaluate to defined($key).  When prototyping,
! 	    # it's a pain to write "defined", so I store '1' for the
! 	    # time being. This may have side effects. -- obuk
! 
!             #$fnt{$key}=$val;
!             $fnt{$key} = $val // '1';
          }
          elsif ($stg == 2)
          {
***************
*** 3206,3212 ****
              $r[0]='u0020' if $r[3] == 32;
              $r[0]="u00".hex($r[3]) if $r[0] eq '---';
              $r[4]=$r[0] if !defined($r[4]);
!             $fnt{NAM}->{$r[0]}=[$p[0],$r[3],'/'.$r[4],undef,undef,$r[5],$p[1]||0,$p[2]||0];
              $fnt{NO}->[$r[3]]=$r[0];
              $lastnm=$r[0];
              $lastchr=$r[3] if $r[3] > $lastchr;
--- 3898,3910 ----
              $r[0]='u0020' if $r[3] == 32;
              $r[0]="u00".hex($r[3]) if $r[0] eq '---';
              $r[4]=$r[0] if !defined($r[4]);
!             #$fnt{NAM}->{$r[0]}=[$p[0],$r[3],'/'.$r[4],undef,undef,$r[5],$p[1]||0,$p[2]||0];
! 
! 	    # To visually distinguish between psname and cid, I decided
! 	    # not to put a leading '/' on cid. -- obuk
! 
!             my $psname = ($fnt{cidfont} ? '' : '/').$r[4];
!             $fnt{NAM}->{$r[0]}=[$p[0],$r[3],$psname,undef,undef,$r[5],$p[1]||0,$p[2]||0];
              $fnt{NO}->[$r[3]]=$r[0];
              $lastnm=$r[0];
              $lastchr=$r[3] if $r[3] > $lastchr;
***************
*** 3218,3224 ****
              $fntbbox[3]=$p[1] if defined($p[1]) and $p[1] > $fntbbox[3];
              $ascent=$p[1] if defined($p[1]) and $p[1] > $ascent and $r[3] >= 32 and $r[3] < 128;
              $charset.='/'.$r[4] if defined($r[4]);
!             $capheight=$p[1] if length($r[4]) == 1 and $r[4] ge 'A' and $r[4] le 'Z' and $p[1] > $capheight;
          }
      }
  
--- 3916,3923 ----
              $fntbbox[3]=$p[1] if defined($p[1]) and $p[1] > $fntbbox[3];
              $ascent=$p[1] if defined($p[1]) and $p[1] > $ascent and $r[3] >= 32 and $r[3] < 128;
              $charset.='/'.$r[4] if defined($r[4]);
!             #$capheight=$p[1] if length($r[4]) == 1 and $r[4] ge 'A' and $r[4] le 'Z' and $p[1] > $capheight;
!             $capheight=$p[1] if $r[3] >= ord('A') and $r[3] <= ord('Z') and $p[1] > $capheight;
          }
      }
  
***************
*** 3238,3243 ****
--- 3937,3957 ----
      $slant=-$fnt{'slant'} if exists($fnt{'slant'});
      $fnt{slant}=$slant;
      $fnt{nospace}=(!defined($fnt{NAM}->{u0020}->[PSNAME]) or $fnt{NAM}->{u0020}->[PSNAME] ne '/space' or !exists($fnt{'spacewidth'}))?1:0;
+ 
+     # otftodit stores the cid in $fnt{NAM}->{u0020}->[PSNAME] for the
+     # cidfont (otf), so I compare $fnt{NAM}->{u0020}->[PSNAME] with
+     # $fnt{NAM}->{space}->[PSNAME], not with 'space'. -- obuk
+ 
+     if ($fnt{cidfont}) {
+       $fnt{nospace}=(
+           !defined($fnt{NAM}->{u0020}->[PSNAME]) or
+           !defined($fnt{NAM}->{space}->[PSNAME]) or
+           $fnt{NAM}->{u0020}->[PSNAME] ne $fnt{NAM}->{space}->[PSNAME] or
+           !exists($fnt{'spacewidth'}))?1:0;
+     } else {
+         $fnt{nospace}=(!defined($fnt{NAM}->{u0020}->[PSNAME]) or $fnt{NAM}->{u0020}->[PSNAME] ne '/space' or !exists($fnt{'spacewidth'}))?1:0;
+     }
+ 
      $fnt{'spacewidth'}=270 if !exists($fnt{'spacewidth'});
      Warn("Using nospace mode for font '$ofontnm'") if $fnt{nospace} == 1 and $options & USESPACE;
  
***************
*** 3254,3259 ****
--- 3968,4076 ----
      {
          # Real font needs subsetting
  	$fnt{fontfile}=$download{$fontkey};
+         if ($fnt{opentype} || $fnt{cidfont}) {
+             my $otf = Font::TTF::Font->open($fnt{fontfile});
+             $fnt{' OTF'} = $otf;
+ 
+             if ($fnt{opentype}) {
+                 for (split /\s+/, $fnt{opentype}) {
+                     my ($f, $x) = split /=/;
+                     die $@ unless __PACKAGE__->can($f);
+                     no strict 'refs';
+                     $otf->{uc $f}->read;
+                     $fnt{" \U$f\E"} = &$f($otf, split /,/, $x);
+                 }
+             }
+ 
+             $otf->{'hmtx'}->read;
+             $otf->{'vmtx'}->read;
+ 
+             $otf->{'CFF '}->read;
+             my $gid2cid = $otf->{'CFF '}->Charset->{code};
+             my $cid2gid;
+             for my $gid (0 .. $#{$gid2cid}) {
+                 my $cid = $gid2cid->[$gid];
+                 $cid2gid->[$cid] = $gid if defined $cid;
+             }
+             $fnt{' CID2GID'} = $cid2gid;
+             $fnt{' GID2CID'} = $gid2cid;
+ 
+             $fnt{' CIDSystemInfo'} = {
+                 Registry => "(Adobe)",
+                 Ordering => "(Identity)",
+                 Supplement => 0,
+             };
+ 
+             $fnt{' Encoding'} = $fnt{vertical}? "Identity-V" : "Identity-H";
+             $fnt{' CMapType'} = 2;
+             $fnt{' CMapName'} = join '-', $fnt{name}, $fnt{' Encoding'};
+ 
+             $otf->{name}->read;
+             $fnt{' FontName'}   = get_name($otf, 6);
+             $fnt{' FamilyName'} = get_name($otf, 1);
+             $fnt{' Notice'}     = get_name($otf, 0);
+             $fnt{' Weight'}     = get_name($otf, 2);
+ 
+             $otf->{'post'}->read;
+             for (qw/isFixedPitch ItalicAngle/) {
+                 $fnt{" $_"} =
+                     exists $otf->{'post'}{STRINGS}{lcfirst $_} ?
+                     $otf->{'post'}{STRINGS}{lcfirst $_} :
+                     exists $otf->{'CFF '}->TopDICT->{lcfirst $_} ?
+                     $otf->{'CFF '}->TopDICT->{lcfirst $_} :
+                     exists $otf->{'CFF '}->TopDICT->{ucfirst $_} ?
+                     $otf->{'CFF '}->TopDICT->{ucfirst $_} :
+                     undef;
+                 if (/^[iI]s/) {
+                     #$fnt{" $_"} = $fnt{" $_"}? 'true' : 'false';
+                 }
+             }
+ 
+             if ($fnt{' ItalicAngle'} == 0 && $fnt{slant}) {
+                 my $angle = -$fnt{slant};
+                 $angle = rad($angle);
+ 		# see Figure 13 in PDF 32000-1:2008
+                 $fnt{' skew'} = sin($angle)/cos($angle);
+             }
+ 
+             $fnt{' FontBBox'} = $otf->{'CFF '}->TopDICT->{FontBBox};
+ 
+             $otf->{'OS/2'}->read;
+             $fnt{' Ascender'}  = $otf->{'OS/2'}{sTypoAscender};
+             $fnt{' Descender'} = $otf->{'OS/2'}{sTypoDescender};
+             $fnt{' CapHeight'} = $otf->{'OS/2'}{CapHeight};
+ 
+             $fnt{' DW'} = 1000;
+             $fnt{' DW2'} = [ 1000 + $fnt{' Descender'}, -1000 ];
+ 
+             0 and do {
+                 for (
+ 
+                     qw/ vertical Encoding CMapType CMapName FontName
+                         FamilyName Notice Weight isFixedPitch
+                         ItalicAngle slant FontBBox fntbbox Ascender ascent
+                         Descender CapHeight capheight /
+ 
+                 ) {
+                     my $v;
+                     if (defined ($v = $fnt{" $_"})) {
+                         if (ref $v) {
+                             print STDERR join ' => ', "' $_'", "[ ".join(', ', @$v)." ]", "\n";
+                         } else {
+                             print STDERR join ' => ', "' $_'", "'$v'", "\n";
+                         }
+                     } elsif (defined ($v = $fnt{$_})) {
+                         if (ref $v) {
+                             print STDERR join ' => ', "'$_'", "[ ".join(', ', @$v)." ]", "\n";
+                         } else {
+                             print STDERR join ' => ', "'$_'", "'$v'", "\n";
+                         }
+                     } else {
+                         print STDERR join ' => ', "'$_'", "undef", "\n";
+                     }
+                 }
+             };
+         }
  #         my ($head,$body,$tail)=GetType1($download{$fontkey});
  #         $head=~s/\/Encoding .*?readonly def\b/\/Encoding StandardEncoding def/s;
  #         $fontlst{$fontno}->{HEAD}=$head;
***************
*** 3561,3571 ****
--- 4378,4399 ----
  {
      my $par=shift;
      my $fnt=$fontlst{$par}->{FNT};
+     my $mm = 0;
+     if ($thisfnt) {
+         if ($thisfnt->{name} ne $fnt->{name}) {
+             PutLine();              # xxxxx - flush @line
+         }
+         if (($thisfnt->{vertical} // 0) != ($fnt->{vertical} // 0) ||
+             ($thisfnt->{' skew'}  // 0) != ($fnt->{' skew'}  // 0)) {
+             $mm = 1;
+         }
+     }
      $thisfnt=$fnt;
  
      #   IsText();
      $cft="$par";
      $fontchg=1;
+     MakeMatrix() if $mm;
      PutLine();
  }
  
***************
*** 3573,3579 ****
  {
      if ($mode eq 'g')
      {
!         $stream.="q BT\n$matrix ".PutXY($xpos,$ypos)." Tm\n";
          $poschg=0;
          $matrixchg=0;
          $tmxpos=$xpos;
--- 4401,4411 ----
  {
      if ($mode eq 'g')
      {
!         my $dy = 0;
!         $dy = $cftsz / 1000 * (500 + $thisfnt->{' Descender'})
!             if $thisfnt && $thisfnt->{vertical};
!         $stream.="q BT\n$matrix ".PutXY($xpos,$ypos - $dy)." Tm\n";
!         #$stream.="q BT\n$matrix ".PutXY($xpos,$ypos)." Tm\n";
          $poschg=0;
          $matrixchg=0;
          $tmxpos=$xpos;
***************
*** 3592,3598 ****
      {
          PutLine(0) if $matrixchg;
          shift(@lin) if $#lin==0 and !defined($lin[0]->[CHR]);
!         $stream.="$matrix ".PutXY($xpos,$ypos)." Tm\n", $poschg=0;
          $tmxpos=$xpos;
          $matrixchg=0;
          $stream.="$curkern Tc\n";
--- 4424,4434 ----
      {
          PutLine(0) if $matrixchg;
          shift(@lin) if $#lin==0 and !defined($lin[0]->[CHR]);
!         my $dy = 0;
!         $dy = $cftsz / 1000 * (500 + $thisfnt->{' Descender'})
!             if $thisfnt && $thisfnt->{vertical};
!         $stream.="$matrix ".PutXY($xpos,$ypos - $dy)." Tm\n", $poschg=0;
!         #$stream.="$matrix ".PutXY($xpos,$ypos)." Tm\n", $poschg=0;
          $tmxpos=$xpos;
          $matrixchg=0;
          $stream.="$curkern Tc\n";
***************
*** 4067,4087 ****
  
      $stream.="%! wht0sz=".d3($whtsz/$unitwidth).", wt=".((defined($wt))?d3($wt/$unitwidth):'--')."\n" if $debug;
  
      foreach my $c (@lin)
      {
          my $chr=$c->[CHR];
          my $char;
          my $chrc=defined($chr)?$c->[CHF]->[MAJOR].'/'.$chr:'';
!         $chrc.="(".chr(abs($chr)).")" if defined($chr) and $cftmajor==0 and $chr<128;
!         $chrc.="[$c->[CHF]->[PSNAME]]" if defined($chr);
  
          if (defined($chr))
          {
!             $chr=abs($chr);
!             $char=chr($chr);
!             $char="\\\\" if $char eq "\\";
!             $char="\\(" if $char eq "(";
!             $char="\\)" if $char eq ")";
          }
  
          $stream.="%! PutLine: XPOS=$c->[XPOS], CHR=$chrc, CWID=$c->[CWID], HWID=$c->[HWID], NOMV=$c->[NOMV]\n" if $debug;
--- 4903,4950 ----
  
      $stream.="%! wht0sz=".d3($whtsz/$unitwidth).", wt=".((defined($wt))?d3($wt/$unitwidth):'--')."\n" if $debug;
  
+     my @TJ;
      foreach my $c (@lin)
      {
          my $chr=$c->[CHR];
          my $char;
+         my $placement;
+ 
          my $chrc=defined($chr)?$c->[CHF]->[MAJOR].'/'.$chr:'';
!         #$chrc.="(".chr(abs($chr)).")" if defined($chr) and $cftmajor==0 and $chr<128;
!         #$chrc.="[$c->[CHF]->[PSNAME]]" if defined($chr);
  
          if (defined($chr))
          {
!             my $psname = $c->[CHF]->[PSNAME];
!             if (substr($psname, 0, 1) eq '/') {
!                 $chr=abs($chr);
!                 $char=chr($chr);
!                 $char="\\\\" if $char eq "\\";
!                 $char="\\(" if $char eq "(";
!                 $char="\\)" if $char eq ")";
!                 $char = "($char)";
!                 $chrc.="(".chr(abs($chr)).")" if $cftmajor==0 and $chr < 128;
!             } else {
!                 if (my $otf = $thisfnt->{' OTF'}) {
!                     my $gid = $thisfnt->{' CID2GID'}->[$psname];
!                     #$char = sprintf "<%04X>", $gid;
!                     $char = sprintf "<%04X>", $psname;
!                     if (my $v = $thisfnt->{' GPOS'}{$gid}) {
!                         if ($thisfnt->{vertical}) {
!                             for ($v->{'YPlacement'}) {
!                                 $placement = $_ if defined;
!                             }
!                         } else {
!                             for ($v->{'XPlacement'}) {
!                                 $placement = $_ if defined;
!                             }
!                         }
!                     }
!                     $chrc.=$char;
!                 }
!             }
!             $chrc .= "[$psname]";
          }
  
          $stream.="%! PutLine: XPOS=$c->[XPOS], CHR=$chrc, CWID=$c->[CWID], HWID=$c->[HWID], NOMV=$c->[NOMV]\n" if $debug;
***************
*** 4106,4111 ****
--- 4969,4975 ----
                      {
                          $s.="(",$n=0 if $n;
                          $s.=' ' x $i;
+                         push @TJ, "(" . ' ' x $i . ")";
                          $gap-=($whtsz+$wt) * $i;
                      }
                  }
***************
*** 4119,4124 ****
--- 4983,4993 ----
              {
                  $s.=') ' if !$n;
                  $s.=d3(-$gap/$cftsz).' (';
+                 if ($thisfnt->{vertical}) {
+                     push @TJ, d3($gap/$cftsz); # xxxxx
+                 } else {
+                     push @TJ, d3(-$gap/$cftsz);
+                 }
                  $n=0;
              }
          }
***************
*** 4128,4139 ****
--- 4997,5022 ----
              {
                  $s.=') ' if !$n;
                  $s.=d3(($c->[CWID]-$c->[HWID])*100).' (';
+                 if ($thisfnt->{vertical}) {
+                     push @TJ, d3(-($c->[CWID]-$c->[HWID])*100); # xxxxx
+                 } else {
+                     push @TJ, d3(($c->[CWID]-$c->[HWID])*100);
+                 }
                  $n=0;
              }
  
              if (defined($chr))
              {
                  $s.=' (',$n=0 if $n;
+                 if (defined $placement) {
+                     #if ($thisfnt->{vertical}) {
+                         push @TJ, -$placement, $char, $placement; # xxxxx
+                     #} else {
+                     #    push @TJ, $placement, $char, -$placement;
+                     #}
+                 } else {
+                     push @TJ, $char;
+                 }
                  $s.=$char;
              }
  
***************
*** 4141,4146 ****
--- 5024,5034 ----
              {
                  $s.=') ' if !$n;
                  $s.=d3((($c->[CWID]-$c->[HWID])*1000)/$cftsz).' (';
+                 if ($thisfnt->{vertical}) {
+                     push @TJ, d3((-($c->[CWID]-$c->[HWID])*1000)/$cftsz); # xxxxx
+                 } else {
+                     push @TJ, d3((($c->[CWID]-$c->[HWID])*1000)/$cftsz);
+                 }
                  $n=0;
              }
  
***************
*** 4149,4154 ****
--- 5037,5051 ----
          else
          {
              $s.="(",$n=0 if $n;
+             if (defined $placement) {
+                 #if ($thisfnt->{vertical}) {
+                     push @TJ, -$placement, $char, $placement; # xxxxx
+                 #} else {
+                 #    push @TJ, $placement, $char, -$placement;
+                 #}
+             } else {
+                 push @TJ, $char;
+             }
              $s.=$char;
          }
      }
***************
*** 4157,4164 ****
      $s.=")" if !$n;
      $s.=d3(-$len) if $len;
      $wt=0 if !defined($wt);
!     $stream.=d3($wt/$unitwidth)." Tw ";
!     $stream.="$s] TJ\n";
      @lin=();
      $wt=undef;
      $whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
--- 5054,5062 ----
      $s.=")" if !$n;
      $s.=d3(-$len) if $len;
      $wt=0 if !defined($wt);
!     $stream.=d3($wt/$unitwidth)." Tw " if $options & USESPACE;
!     #$stream.="$s] TJ\n";
!     $stream.="[ @TJ ] TJ\n";
      @lin=();
      $wt=undef;
      $whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
***************
*** 4268,4280 ****
          AssignGlyph($fnt,$chf,$ch);
      }
  
!     if ($fontchg or $chf->[MAJOR] != $cftmajor)
      {
          PutLine();
          $cftmajor=$chf->[MAJOR];
          #       $whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
          my $c=$cft;
!         $c.=".".$cftmajor if $cftmajor;
          $stream.="/F$c $cftsz Tf\n";
          $fontchg=0;
      }
--- 5166,5178 ----
          AssignGlyph($fnt,$chf,$ch);
      }
  
!     if ($fontchg or $chf->[MAJOR] != $cftmajor && !$fnt->{cidfont})
      {
          PutLine();
          $cftmajor=$chf->[MAJOR];
          #       $whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
          my $c=$cft;
!         $c.=".".$cftmajor if $cftmajor && !$fnt->{cidfont};
          $stream.="/F$c $cftsz Tf\n";
          $fontchg=0;
      }
***************
*** 4311,4317 ****
  
          if ($matrixchg or $poschg)
          {
!             $stream.="$matrix ".PutXY($xpos,$ypos)." Tm\n", $poschg=0;
              $tmxpos=$xpos;
              $matrixchg=0;
              $stream.="$curkern Tc\n";
--- 5209,5219 ----
  
          if ($matrixchg or $poschg)
          {
!             my $dy = 0;
!             $dy = $cftsz / 1000 * (500 + $thisfnt->{' Descender'})
!                 if $thisfnt && $thisfnt->{vertical};
!             $stream.="$matrix ".PutXY($xpos,$ypos - $dy)." Tm\n", $poschg=0;
!             #$stream.="$matrix ".PutXY($xpos,$ypos)." Tm\n", $poschg=0;
              $tmxpos=$xpos;
              $matrixchg=0;
              $stream.="$curkern Tc\n";
***************
*** 4322,4328 ****
  #     $stream.="%!!! Put: font=$cft, char=$chf->[PSNAME]\n" if $debug;
  
      push(@lin,[$cn,$xpos,$cwid,$hwid,$nowidth,$chf]);
- 
      $xpos+=$hwid;
  }
  
--- 5224,5229 ----
***************
*** 4959,4968 ****
--- 5860,5993 ----
  
      return($res.'+');
  }
+ 
+ 
+ sub get_name {
+     my ($otf, $number, $platform_id, $encoding_id, $language_id) = @_;
+     $platform_id //= 3;
+     $encoding_id //= 1;
+     $language_id //= 0x409;
+     $otf->{name}->read;
+     $otf->{name}{strings}[$number][$platform_id][$encoding_id]{$language_id};
+ }
+ 
+ 
+ sub gsub {
+     my $otf = shift;
+ 
+     my $gsub;
+     for my $index (grep defined, @_) {
+         my $value = $otf->{GSUB}{LOOKUP}[$index];
+         if ($value->{TYPE} == 1) {
+             for (@{$value->{SUB}}) {
+                 while (my ($gid, $i) = each %{$_->{COVERAGE}{val}}) {
+                     $gsub->{$gid} = $_->{RULES}[$i][0]{ACTION}[0];
+                 }
+             }
+         } elsif ($value->{TYPE} == 4) {
+             for (@{$value->{SUB}}) {
+                 while (my ($gid, $i) = each %{$_->{COVERAGE}{val}}) {
+                     for (@{$_->{RULES}[$i]}) {
+                         $gsub->{join $;, @{$_->{ACTION}}} =
+                             [ $gid + 0, @{$_->{MATCH}} ];
+                     }
+                 }
+             }
+         } else {
+             die "gsub: unknown \$value->{TYPE}: $value->{TYPE}";
+         }
+     }
+     $gsub;
+ }
+ 
+ 
+ sub gpos {
+     my $otf = shift;
+ 
+     my $gpos;
+     for my $index (grep defined, @_) {
+         my $value = $otf->{GPOS}{LOOKUP}[$index];
+ 
+         if ($value->{TYPE} == 1) {
+ 
+             # Lookup type 1 subtable: single adjustment positioning
+ 
+             for (@{$value->{SUB}}) {
+                 while (my ($gid, $i) = each %{$_->{COVERAGE}{val}}) {
+                     for (@{$_->{RULES}[$i]}) {
+                         for (@{$_->{ACTION}}) {
+                             while (my ($k, $v) = each %$_) {
+                                 $gpos->{$gid}{$k} = $v;
+                             }
+                         }
+                     }
+                 }
+             }
+ 
+         } elsif ($value->{TYPE} == 2) {
+ 
+             # Lookup type 2 subtable: pair adjustment positioning
+ 
+             my $sub_index = 0;
+             for (@{$value->{SUB}}) {
+ 
+                 my @gid;
+                 while (my ($gid, $i) = each %{$_->{COVERAGE}{val}}) {
+                     $gid[$i] = $gid;
+                 }
+ 
+                 my $MATCH_TYPE  = $_->{MATCH_TYPE};
+                 my $ACTION_TYPE = $_->{ACTION_TYPE};
+ 
+                 if ($MATCH_TYPE eq 'g' && $ACTION_TYPE eq 'p') {
+ 
+                     my $PairSetCount = @{$_->{RULES}};
+                     for my $i (0 ..  $PairSetCount - 1) {
+                         my $PairValueCount = @{$_->{RULES}[$i]};
+                         for my $j (0 ..  $PairValueCount - 1) {
+                             my $gid2 = $_->{RULES}[$i][$j]{MATCH}[0];
+                             $gpos->{$gid[$i], $gid2} =
+                                 $_->{RULES}[$i][$j]{ACTION}[0];
+                         }
+                     }
+ 
+                 } elsif ($MATCH_TYPE eq 'c' && $ACTION_TYPE eq 'p') {
+ 
+                     # $_->{FORMAT} = 2: Pair adjustment positioning
+                     # format 2: class pair adjustment
+ 
+                     # MATCH_TYPE = 'c': An array of class values
+                     # ACTION_TYPE = 'p': Pair adjustment
+ 
+                     for my $gid (@gid) {
+                         my $c = $_->{CLASS}{val}{$gid};
+                         next unless defined $c;
+                         while (my ($gid2, $c2) = each %{$_->{MATCH}[0]{val}}) {
+                             next unless $c2;
+                             $gpos->{$gid, $gid2} = $_->{RULES}[$c][$c2]{ACTION}[0];
+                         }
+                     }
+ 
+                 } else {
+                     die "gpos: unknown \$_->{FORMAT}: $_->{FORMAT} in TYPE 2";
+                 }
+ 
+             }
+ 
+         } else {
+             die "gpos: unknown \$value->{TYPE}: $value->{TYPE}";
+         }
+     }
+ 
+     $gpos;
+ }
+ 
  1;
  
  # Local Variables:
  # fill-column: 72
+ # tab-width: 8
+ # indent-tabs-mode: t
  # mode: CPerl
  # End:
  # vim: set cindent noexpandtab shiftwidth=4 softtabstop=4 textwidth=72:
